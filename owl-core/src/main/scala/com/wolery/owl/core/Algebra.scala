//**************************** Copyright © Jonathon Bell. All rights reserved.
//*
//*
//*  Version : $Header:$
//*
//*
//*  Purpose : Defines type classes for the various algebraic constructions we
//*            shall be leveraging throughout the library.
//*
//*            Our principle interest is in the action of the ring of integers
//*            upon such sets as the (even tempered) pitches and notes,  hence
//*            our choice of an additive notation for groups and the like, and
//*            our singling out of transposing and intervallic sets as special
//*            instances of these more general constructs.
//*
//*            Implicit wrappers that provide  syntactic sugar for the classes
//*            in the form of overloaded arithmetic operators are also defined
//*            within the core package object.
//*
//*  Comments: This file uses a tab size of 2 spaces.
//*                                                                     0-0
//*                                                                   (| v |)
//**********************************************************************w*w***

package com.wolery.owl
package core

/**
 * Describes the operations that endow the data type `S` with the structure of
 * a semigroup.
 *
 * Instances satisfy the axiom:
 * {{{
 *     (s₁ ⋅ s₂) ⋅ s₃ = s₁ ⋅ (s₂ ⋅ s₃)                   associativity
 * }}}
 * for all `sᵢ` in `S`, where `⋅` denotes the binary function `operate`.
 *
 * In other words, `S` is an associative magma.
 *
 * @tparam S  The carrier set on which the binary operator `⋅` acts.
 *
 * @see    [[https://en.wikipedia.org/wiki/Semigroup Semigroup (Wikipedia)]]
 * @see    [[SemigroupSyntax]]
 *
 * @author Jonathon Bell
 */
trait Semigroup[S]
{
  /**
   * Returns the product of the given pair of elements, whatever this may mean
   * for the specific algebraic structure in question.
   *
   * The function is ''associative''; that is, `(s₁ ⋅ s₂) ⋅ s₃ = s₁ ⋅ (s₂ ⋅ s₃)`
   * for all `sᵢ` in `S`, where `⋅` denotes the binary function `operate`.
   *
   * @see    [[https://en.wikipedia.org/wiki/Associative_property Associative
   *         property (Wikipedia)]]
   */
  def operate(s: S,t: S): S
}

/**
 * Describes the operations that endow the data type `M` with the structure of
 * a monoid.
 *
 * Instances satisfy the axioms:
 * {{{
 *            e ⋅ m = m = m ⋅ e                          identity
 *     (m₁ ⋅ m₂) ⋅ m₃ = m₁ ⋅ (m₂ ⋅ m₃)                   associativity
 * }}}
 * for all `mᵢ` in `M`, where `⋅` denotes the binary function `operate`.
 *
 * In other words, `M` is a semigroup with an identity element.
 *
 * @tparam M  The carrier set on which the binary operator `⋅` acts.
 *
 * @see    [[https://en.wikipedia.org/wiki/Monoid Monoid (Wikipedia)]]
 *
 * @author Jonathon Bell
 */
trait Monoid[M] extends Semigroup[M]
{
  /**
   * The identity element of the monoid `M`;  that is,  the unique element `e`
   * in `M` such that `e ⋅ m = m = m ⋅ e` for all `m` in `M` where `⋅` denotes
   * the binary function `operate`.
   */
  val e: M
}

/**
 * Describes the operations that endow the data type `G` with the structure of
 * a group.
 *
 * Instances satisfy the axioms:
 * {{{
 *            e ⋅ g = g = g ⋅ e                          identity
 *     (g₁ ⋅ g₂) ⋅ g₃ = g₁ ⋅ (g₂ ⋅ g₃)                   associativity
 *           g ⋅ -g = e = -g ⋅ g                         invertability
 * }}}
 * for all `gᵢ` in `G`, where `⋅` and  `-` denote the  functions `operate` and
 * `inverse` respectively.
 *
 * In other words, `G` is a monoid in which every element possesses an inverse
 * element.
 *
 * @tparam G  The carrier set on which the binary operator `⋅` acts.
 *
 * @see    [[http://en.wikipedia.org/wiki/Group_(mathematics) Group (Wikipedia)]]
 * @see    [[GroupSyntax]]
 *
 * @author Jonathon Bell
 */
trait Group[G] extends Monoid[G]
{
  /**
   * Returns the inverse of the element `g`;  that is, the unique element `-g`
   * in  `G` such  that  `g ⋅ -g = e = -g ⋅ g`,  where `⋅` denotes  the binary
   * function `operate`.
   */
  def inverse(g: G): G
}

/**
 * Describes a (right) action of the group `G` upon the carrier set `S`.
 *
 * Instances satisfy the axioms:
 * {{{
 *            s + e = s                                  identity
 *    s + (g₁ ⋅ g₂) = (s + g₁) + g₂                      compatability
 * }}}
 * for all `sᵢ` in `S` and `g` in `G`, where `⋅` and  `+` denote the functions
 * `operate` and `apply` respectively.
 *
 * In other words, `+` is a homomorphism from `G` into `Sym(S)`, the symmetric
 * group consisting of all permutations of `S`,  regarded as a group under the
 * composition of mappings.
 *
 * Group actions, especially those of `(ℤ,+)`, the set of integers regarded as
 * an additive group, are of special interest to us in Owl because they enable
 * us to model permutations of pitches, notes, scales, and so on, using simple
 * integer arithmetic.
 *
 * Notice than when `G` is cyclically generated by some element `g`, an action
 * of `G` upon `S` is completely determined by the permutation  `_ + g`. Thus,
 * in particular, a `ℤ`-set is uniquely determined by the function `_ + 1`.
 *
 * @tparam G  A group that acts upon the carrier set  `S` via the mapping `apply`.
 * @tparam S  A non-empty set acted upon by the group `G` via the mapping `apply`.
 *
 * @see    [[http://en.wikipedia.org/wiki/Group_action Group action (Wikipedia)]]
 * @see    [[ActionSyntax]]
 *
 * @author Jonathon Bell
 */
abstract class Action[S,G](implicit val group: Group[G])
{
  /**
   * Applies an element of the group `G` to an element of the carrier set `S`,
   * whatever this may mean for the specific algebraic structure in question.
   *
   * It follows from the axioms that the function `_ + g` is a  permutation of
   * the carrier set `S`,  and furthermore that `apply` is a homomorphism from
   * `G` into `Sym(S)`,  the symmetric group consisting of all of permutations
   * of `S`, regarded as a group under the composition of mappings.
   *
   * @param  s  An element of the carrier set `S`.
   * @param  f  An element of the acting group `G`.
   *
   * @return The result of applying the permutation denoted by `g` to the set
   *         element `s`.
   */
  def apply(s: S,g: G): S
}

/**
 * Describes a regular (right) action of the group `G` upon the carrier set
 * `S`.
 *
 * By ''regular'' we mean that the action is ''sharply transitive'';  that is,
 * for every pair of elements  `s₁` and `s₂` in `S`  there exists a ``unique``
 * element `s₂ - s₁` in `G` such that `s₁ + (s₂ - s₁) = s₂`, where `+` and `-`
 * denote the functions `apply` and `delta` respectively.
 *
 * Instances satisfy the axioms:
 * {{{
 *            s + e = s                                  identity
 *    s + (g₁ ⋅ g₂) = (s + g₁) + g₂                      compatability
 *         s₁ + (s₂ - s₁) = s₂                           regularity
 * }}}
 * for all `sᵢ` in `S`,  where `+` and `-` denote the binary functions `apply`
 * and `delta` respectively.
 *
 * We say that `S` is a ''torsor'' for the group `G`,  or simply that `S` is a
 * ''`G`-torsor''.
 *
 * Torsors,  especially those of `(ℤ,+)`, the integers regarded as an additive
 * group, and ℤ/''n''ℤ,  the integers modulo ''n'', are of special interest to
 * us in Owl  because they make precise the musical notion of the ''interval''
 * between two notes, pitches, frequencies, and so on.
 *
 * @tparam G  A group that acts regularly upon the carrier set  `S` via the mapping `apply`.
 * @tparam S  A non-empty set acted upon regularly by the group `G` via the mapping `apply`.
 *
 * @see    [[http://en.wikipedia.org/wiki/Principal_homogeneous_space Torsor (Wikipedia)]]
 * @see    [[http://math.ucr.edu/home/baez/torsors.html Torsors Made Easy (John Baez)]]
 * @see    [[TorsorSyntax]]
 *
 * @author Jonathon Bell
 */
trait Torsor[S,G] extends Action[S,G]
{
  /**
   * Returns the 'delta' between the given pair of elements of the carrier set
   * `S`; that is, the unique element `g` in `G` such that `s + g = t`,  where
   * `+` denotes the binary function `apply`.
   *
   * @param  s  An element of the carrier set `S`.
   * @param  t  An element of the carrier set `S`.
   *
   * @return The unique element of `G` that maps `s` into `t`.
   */
  def delta(s: S,t: S): G
}

/**
 * Implements the regular (right) action of the group `G` upon itself.
 *
 * Every group `G` is  isomorphic to a  subgroup of the symmetric group acting
 * on `G`, a result known as ''Cayley's Theorem''.
 *
 * Equivalently, and restating in the language of group actions, `G` acts upon
 * itself regularly by (right) multiplication, This action is known as the
 * ''regular action'' of `G` upon itself.
 *
 *
 *
 * , thus is a `G-torsor`.
 *
 * This action of `G` upon itself by (right) multiplication is regular, and is
 * known as the ''regular action''.
 *
 * This class exploits this fact to automatically instantiate a `G-torsor` for
 * `G`, so simplifying the task of adding new groups to the Owl system.
 *
 * For example:
 * {{{
 *    implicit object isℤTorsor extends RegularAction[ℤ]
 * }}}
 * implements the regular action of the additive group of integers `(ℤ,+)` on
 * itself via (right) addition.
 *
 * @tparam G  An instance of the type class `Group`.
 *
 * @see    [[https://en.wikipedia.org/wiki/Cayley%27s_theorem Cayley's Theorem
 *         (Wikipedia)]]
 *
 * @author Jonathon Bell
 */
class RegularAction[G: Group] extends Torsor[G,G]
{
  def apply(f: G,g: G): G   = f ⋅  g
  def delta(g: G,f: G): G   = f ⋅ -g
}

/**
 * Derives the induced action of `G` upon the power set of `S` from the given
 * action of `G` upon `S`.
 *
 * For any action `⋅` of the group `G` on the set `S` we may define the map:
 * {{{
 *    T⋅g  =  {t⋅g : t ∈ T}
 * }}}
 * for all `g` in `G` and `T` in `P(S)`, the power set of `S`. This mapping is
 * an action of `G` upon `P(S)`, and is known as the ''induced action upon the
 * power set''.
 *
 * @tparam S  A non-empty set acted upon by the group `G` via the mapping `apply`.
 * @tparam G  A group that acts upon the carrier set  `S` via the mapping `apply`.
 *
 * @see    [[http://en.wikipedia.org/wiki/Group_(mathematics) Group (Wikipedia)]]
 *
 * @author Jonathon Bell
 */
class PowerSetAction[S,G: Group](implicit ε: Action[S,G]) extends Action[Set[S],G]
{
  def apply(s: Set[S],g: G): Set[S] = s.map(ε(_,g))
}

//****************************************************************************
